package hot100._05_ordinary_array;

import java.util.Arrays;

/**
 * @author AiJun
 * @version 1.0
 * <p>
 * Description: 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。  子数组 是数组中的一个连续部分。
 * <p>
 * Last Modified:
 * @date 2025/1/2 15:50
 */
public class _013_MaxSubArray {
    /*
    一开始的思路是使用滑动窗口，因为看到了连续子数组，所以觉得可以动态移动滑动窗口来比较值，这个思路如下，
    1.我们先构建一个窗口，然后窗口右边增大，如果新窗口的值大于之前的，说明现在这个窗口是有效的，
    2.但是有可能子窗口更大，所以左边尝试缩小，如果就更大的值就固定住，没有就是原来的旧窗口，
    3.然后我们继续扩大窗口，右移右边，如果新的值更大就暂时固定住然后继续找子窗口，如果一直没有新窗口更大，那么就回到之前的一个窗口，
    4.目前为止应该还有一个问题，那就是第3步，一直没找到最大值只能说明从左边窗口开始扩展一直到最右边没有更大的值，可能是老窗口的值很小，老窗口的右边可能会有新窗口满足条件
    5.所以当第3步遍历后，直接从旧窗口的右边开始重新遍历，直到结束
     */
    /*
    上面是我一开始的思路，执行起来会很复杂，其实从上述的执行步骤中我们发现最大的一个问题就是窗口最大值的判定是很难的，而且会发现，这更像一个动态规划问题
    就是存在递推公式的，例如。。。x。。。。。，x前面的窗口最大值确定了，而且是以x前面的一个数结尾的值是确定的，那么以x结尾确定的最大窗口值立刻就能确定，dp数组
    的值就是以i元素结尾的最大窗口的值，然后我们找到最大的值即可
     */
    public int maxSubArray(int[] nums) {
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        for (int i = 1; i < nums.length; i++) {
            /*dp[i]就是第i个元素结尾的最大窗口的值，现在需要判断需不需要将i前面的窗口连接上，如果值更大了，就连接上，如果连接上没有第i元素大，那么就没必要连接上
            这里面的判断可能存在一个误区，就是判断前面的窗口加上第i个值是不是大于之前的窗口的值，这是错误，因为我们首先就要保证第i个元素一定要在窗口里面，因为他是结尾的
            所以我们要判断之前的窗口加上i元素和i元素本身的大小，也就是之前窗口是否小于0
            */
            if (dp[i - 1] < 0) {
                dp[i] = nums[i];
            } else {
                dp[i] = dp[i - 1] + nums[i];
            }
        }
        return Arrays.stream(dp).max().getAsInt();
    }

    public static void main(String[] args) {
        _013_MaxSubArray maxSubArray= new _013_MaxSubArray();
        System.out.println(maxSubArray.maxSubArray(new int[]{-2, 1, -3, 4, -1, 2, 1, -5, 4}));
    }

}

